---
title: Future of Coding Plan
---

# Future of Coding Plan

Last month, I set aside a single day -- October 16th, 2017 -- to write up [my life plan](http://stevekrouse.com). It summarized my past and current philosophies on life. One goal of this plan was to set the foundation for my work plan for the Future of Coding. Possibly the most important part of my life plan was setting my priorities:

1. My mental health
2. The mental health of my significant other
3. The mental health of my mom, dad, and brothers
4. My physical health
5. My relationship with my significant other
6. My relationships with my mom, dad, and brothers
7. My relationships with my ~5 closest friends
8. My work
9. My relationships with my extended family
10. My relationships with my ~20 closest friends

Note that work is #8. Speaking of work, creating this work plan has proved more difficult. This is potentially because I've had a crappy time getting rid of a stubborn cold. Or perhaps because by not doing it in a single day gives other people the opportunity to give me feedback which undermines my confidence in the plan I created the day before and leads me to starting over.

## Versions of this plan 

For some reason, I think it's important to explain how I arrived at my ideas, not just giving you the polished final version. Let me show you my steps. You can even see my eraser marks.

### 1. [/about](https://github.com/stevekrouse/futureofcoding.org/commit/16321d65a0381b78a1aa049d4666aadac9db8319#diff-6083a88ee3411b0d17ce02d738f69d47)

My first draft did a good job of justifying the path I was currently on. I articulated my goal of making "programming as intuative as Facebook", and my strategy of getting there by building "a functional reactive Scratch."" The next steps, according to this plan, are FRP research (Conal Elliot, Reflex, CycleJS, Elm, Reflex), working on my design principles, and starting to prototype!

### 2. [/plan v1](https://github.com/stevekrouse/futureofcoding.org/commit/4d37f65a04b418772687da1645d1da8d01a4fc30#diff-f763d4e632c0df8461069772c5498887)

Where the last version was justifying, this next version was inquiring. It was directly inspired by watching [Chris Granger's SPLASH 2017 keynote](https://www.youtube.com/watch?v=a_o-ZzgpiK8), which I highly recommend. It refocused my attention on the end-user. What do *they* want to do?

I also created the follow chart to help organize my dozen ideas on how to move forward:

| # | Customer  | Sustained by      |  
|---+-----------+-------------------+
| 1 | Students  | Parents           |
| 2 | Students  | Patreon / OC*     |
| 3 | Adults    | Companies         |
| 4 | Adults    | Open Collective   |
| 5 | FoC Ppl*  | Patreon           |
| 6 | FoC Ppl*  | VC Management fee |

    * OC stands for Open Collective. 
    * FoC Ppl stands for "Future of Coding people", other people working on future of programming tools

### 3. [/plan v2](https://github.com/stevekrouse/futureofcoding.org/commit/7385f741463a6cc23b90c724afb2322860e99dbe#diff-f763d4e632c0df8461069772c5498887)

I showed the above table to Dan Shipper last week. He was really excited about #5: doing research, creating prototypes, writing essays, and recording podcasts for the Future of Coding community. It does seem like a good match for me: allowing me to focus on my favorite activities, and get to skip dealing with the logistics of revenue, customers, and employees. This path makes sense as long as I don't care about money (beyond basic sustainability) or having control.

The open questions from this plan are:

1. What if nobody listens? What if nobody builds the future of coding that I write about? 

2. How do I write content that people read? How do I develop a following? 

3. How do I sustain this strategy financially?

4. Will I enjoy being a full time "researcher", instead of an entrepreneur?

### 4. /plan v3 - the current version, below

Yesterday was an cognitive dissonance kind-of day. I spent it talking with three outstanding entrepreneurs in the future of coding space. They made the for-profit model difficult to dismiss. 

Lloyd Tabb of Looker, Paul Chiusano of Unison, and Emmanuel Straschnov of Bubble.is are building respective products for people who work at businesses. There are two clear benefits to this strategy:

1. The for-profit sustainability models makes a lot of sense. If 1) your customer is someone who has money and 2) you provide them with something they cannot get cheaper elsewhere, they will continue to sustain your efforts indefinitely. 

2. Most simple platforms, like Facebook, the iPhone and Scratch, are simple *because* they are so cohesive. As much as I don't like the *idea* of walled-gardens created by one monolithic organization, that's how many of our most intuitive interfaces were created.

At the same time, the research model has been quite successful. Maybe I'd feel less cognitive dissonance if I spent yesterday with the thought-leadership crowd. Some notable examples of research translating to end-users:

* Alan Kay's PARC -> Steve Jobs -> the Mac -> billions of people
* Bret Victor's Learnable Programming -> me -> The Coding Space & WoofJS -> thousands of students
* Elon Musk's Hyperloop -> Hyperloop One -> hopefully millions of people some day soon

Luckily later today, November 10th, 2017, I have a phone call with Nicky Case who seems to be living the researcher dream.

## The Mission

While my strategy/plan still needs work, my mission is becoming clearer. 

It was helpful for me yesterday to contrast my goals with those of Emmanuel's at Bubble.is.

His goal is to *empower businesses to create apps without code*. That's an amazing goal. But it's not my goal. Why? When I use Bubble, I don't feel joy. I don't feel myself getting smarter. I'm not thinking powerful ideas in the Seymour Papert sense. Bubble is (pun not intended) the cheapest and quickest way to get something done. It's about the end-product, the business solution. That's not what programming is for me.

For me, programming is a medium for creative expression. Just like writing. It's how I articulate what's in my head, refine my ideas, and communicate them with others. The medium of coding is different from the medium of writing in the same way that the medium of pictures is different from that of writing.

All media -- writing, pictures, coding -- can be used either use-case: business or artistic. You can write advirtisement copy or a fictional short story. You can create a entreprise software company or share a simple animation with friends.

The same goes for bicyling. Steve Jobs saw the computer as the "bicycle for the mind." You can bike to get somehwere faster or to workout or to simply have fun.

[Pencil Code](https://pencilcode.net)'s mission is to "make programming as simple and powerful as using a pencil." That's pretty close to what I'm going for.

Let's go with this for now: "empowering creative expression through programming"

## The Vision

If that's the mission, what's the vision? 

Here are some quick phrases I've found effective at communicating what I'm trying to do:

1. "Squarespace for apps"
2. "A tool as powerful as JavaScript and as easy to use as Facebook"
3. "A tool as easy to use as Scratch but with a really high ceiling"

### Principles

Those phrases more or less sum up the picture I have in my head. However, there are a few additional principles that are important. If we made a "Squarespace for apps" that didn't embody these principles, I wouldn't consider the job done.

#### Comprehensible

We need more than just access to an open source repository of files and folders. It currently takes hours to get familiar enough with a new codebase even to make a simple change. The organization of code needs to lend itself to comprehensiblilty.

The CycleJS devtools dataflow diagram does a good job of making a codebase quickly comprehensible:

<video preload="none" autoplay loop poster="https://user-images.githubusercontent.com/2288939/32678297-cdd9b3ac-c62f-11e7-8534-861163725b04.png" src="./media/cycle-js-devtools-diagram.mp4" type="video/mp4" style="width:50%"></video>

#### Liberal

As [r0ml says](https://lwn.net/Articles/712376/), the legal right to fork a codebase is not enough. What would be the value in having all of Facebook's code up on Github? It wouldn't allow us to modify the Facebook platform -- we'd only be able to start a competing platform somewhere else.

We need a programming platform that makes it easy for end-users to modify apps in arbitrarily complex ways *as they are running.*

Imagine system where you can select a piece of text in a running app and change it's properties, just like how you can with Inspect Element:

![inspect3](https://user-images.githubusercontent.com/2288939/32678093-f9ccd9fe-c62e-11e7-9986-3f9f5bb5e502.gif)

When I show this to my students, they immediately want to know:

1. Does this change for everyone?
2. Is it saved for me?

Currently the answer to both questions is no, but we can imagine a system where would could answer with a tentative yes to the second question and an even more tentative yes to the first.

Together, comprehensibile and liberal software will enable software to be more decentralized and cheaper because it will drastically increase the number of people who can modify applications.

#### Powerful ways of thinking

There are powerful ways of thinking that can be embedded within programming, such as:

* rapid iteration - immediately seeing how your changes affect the output
* anthropormphization - imagining yourself inside the algorithm
* top-down design - breaking a big task into smaller sub-problems
* composibility - fitting pieces together
* abstracting - generalizing code to work in different contexts
* modeling - understand how state changes over time
* simplicity - build complex systems out of understandble parts

In [Making JavaScript Learnable](https://medium.com/@stevekrouse/woof-d9adf2110fc6), I constrast how ProccessingJS and WoofJS enable thinking:

![screenshot 2017-11-10 at 4 19 50 pm](https://user-images.githubusercontent.com/2288939/32679070-08b75ba2-c633-11e7-8a15-e6c2711265e2.png)

#### Intuitive

While "easy as Facebook" mostly covers it, I want to make clear that it needs to be "learnable" in the Seymour Papert/[Learnable Programming](worrydream.com/LearnableProgramming/) sense.

This means that you don't have to take a class or watch a video to get started. You learn by doing, *learn by building*. As 

Scratch is a perfect example of such an interface, both for its lack of syntax and for the way it [represents types as shapes](https://medium.com/@stevekrouse/types-are-shapes-d6af1e83192f).


#### No Ceiling

While "as powerful as JavaScript" mostly covers it, I want to make clear that this system is not just for kids or just to learn how to code. As Bret says, "these are not training wheels." One of the biggest challenges of this project will be convincing people that this is "real coding", despite it not looking like what they imagine real coding to look like. 

Emmanuel of Bubble.is says visual programming will be a slow revolution. Until you can point to something people already know about and say "that was built with this", this is not "real coding."

### Strategy

How do we get from here to there? Elon made it seem so simple in his first plan for Tesla:

> Build sports car

> Use that money to build an affordable car

> Use that money to build an even more affordable car

> While doing above, also provide zero emission electric power generation options

I think it's safe to say that I don't know enough about this problem to declare my plan so succiently. Yet!

There are so many pieces to this puzzle that need work. Think about all you'd have to explain to a non-programmer:

* the language and syntax
* the comptutational model 
* the underlying technology stack (the internet, the web, the app store)
* setting up their workflow to allow for fast iteration (webpack, hot reloading)
* connecting to databases (SQL, NoSQL, ORM, deployment)
* setting up user accounts and authentication (Rails, Devise)
* setting up deployment (heroku)
* eventually helping with scalability (redis, load balancing)
* collaboration with other developers (git, github, pull requests, issues)
* version control (semantic versioning, releases, cache busting)
* package and dependency management

No wonder coding bootcamps take three months!

### Build or Research?

I think the main question is whether I want to build or research long-term.

On the one hand, builders get shit done. Can I imagine myself starting a company like Looker or Bubble.is? Creating a new open-source langauge/platform like Linux, Clojure or Scratch? One benefit of working on a single project is that it could consolidate further innovation on the remaining problems (listed above) by employees and/or the open source community. 
    
On the other hand, it all starts with research. Can I imagine myself staying in research-mode in perpetuity, like Alan Kay or Bret Victor? Would I be fufilled doing research, making prototypes, and publishing papers?
    
It's clear that both models move the world forward. Without foundational research, people wouldn't know what to build. Without people starting projects, none of the great ideas from research would get built. I guess it comes down to *what am I best at?* and *what do I enjoy most?*

Those are two questions that I don't know that answers to. Yet! Luckily, I don't have to decide now for forever. I can take each model out for a test-drive, see how it goes, and change later if necessary.

### Wrapping up The Coding Space & WoofJS

Besides, I'm getting ahead of myself here. Before I take on "building the future of coding" as either a builder or researcher, I need to wrap up my work with The Coding Space. To me this means communicating what I learned about teaching kids to code over the past years. Writing this essay will take at least a few weeks, maybe even a few months if I do it justice.

In the meanwhile, I'll continue publishing my podcast once a week, spend time talking to people on [the Future of Programming Slack](https://futureprogramming.slack.com), and talking with [people I admire on Twitter](https://twitter.com/stevekrouse/lists/future-of-coding).

### Sustainability

I will also now start looking into various funding options for my work here, particularly for the research and non-profit models because I have much more questions about it than the for-profit model. My current thinking includes:

* starting a Patreon
* talking with foundations
* talking with corporate sponsors
* talking with research groups
* talking with think tanks
* talking to media companies about get paid for my writing content directly

I'd love to have a least $1 or 2k per month coming in in a sustainabile way within the next few months.

### Intriguing Research Topics

After I finish that essay, my next step will be *picking what to research next*. Regardless of whether I'm a builder or researcher, I'll still need to do research as my next step. 

#### Visual Metaphors for Functional Reactive Programming

Because of how easy it is to *understand* a program written in the FRP-style, I am intrigued by finding a way to make functional reactive programming more intuitive via visual metaphors. Doing research here would mean:

* reading Conal Elliot, playing with Fran
* playing with Haskell's Reflex
* prototyping Streamsheets
* prototyping FRP Scratch, FRP Woof

#### A Library For Visual Expression Building

Andre Staltz made an interesting research suggestion [two months ago](/futureofcoding.org/notes/andre-staltz-call-9-11-17.md). Clearly the coding platform of the future will have some "expression builder" that, as Glen Chiacchieri says, will look more like math on paper than math in Google Sheets:

![image](https://user-images.githubusercontent.com/2288939/32679315-04384694-c634-11e7-89f6-207aa873be23.png)
![image](https://user-images.githubusercontent.com/2288939/32679317-075ba280-c634-11e7-94b8-27fda41a7505.png)

Given that this is a core component that *every* tool in this space will need, why not build it into a library that we can all use? The Ace and CodeMirror text editors are underratedly helpful in enabling innovation here. WoofJS would be significantly worse and more fustrating to build without them. 

I imagine this library would be quite similar to Blockly, which enabled me to build [two](http://cycle.thecodingspace.com/#bo4zu4) [prototypes](http://stevekrouse.com/cycle/#todo-mvc) very quickly. The downsides of Blockly were 1) that it was built on top of Google Closure, and 2) that it didn't provide enough customizibility, particularly around the shape of the blocks, which greatly limits the level of innovation that can be done on the computational metaphors.

## Summary

In summary, here's my tentative plan:

1. The next 3-5 weeks will be spent writing about teaching kids to code. I will also continue podcasting, and begin looking into sustainability options for research.

2. The following 4-8 weeks will back to research: probably either into visual metaphors for functional reactive programming, or a library for visual expression building.

3. Figure out whether my research will turn into a project/company or paper.

4. If it's a project, build it. 

5. If it's a paper, write it. 

6. Find something else to research.



<script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-103157758-1', 'auto');
ga('send', 'pageview');

</script>
<script repoPath="stevekrouse/futureofcoding.org" type="text/javascript" src="/unbreakable-links/index.js"></script>