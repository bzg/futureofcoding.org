<h1 id="about---future-of-coding">About - Future of Coding</h1>

<p>Welcome to the podcast and open-journal research project to create the future of coding.</p>

<h2 id="computing-is-power">Computing is power</h2>

<p>Large advantages are confered upon those who know how to instruct computers:</p>

<ol>
  <li>
    <p>As the fabric of the world becomes software, and those that can manipulate software become powerful magicians.</p>
  </li>
  <li>
    <p>Learning to communicate with computers teaches one how to think more clearly, precisely, and powerfully.</p>
  </li>
</ol>

<p>These reasons, among many others, mean there is a lot of value in learning to code. This is why almost everyone who hears that I “teach coding to children” asks if I can teach them to code. However, the current cost of learning to code is high. Lowering this cost could vastly improve the world.</p>

<h2 id="the-usability-our-tools-is-poor">The usability our tools is poor</h2>

<p>The cost of learning to code is high because the langauges and tools that we currently use to communicate with computers have poor usability:</p>

<ol>
  <li>
    <p>They require hundreds of hours grueling of practice to learn to use.</p>
  </li>
  <li>
    <p>Even after you are familiar with them, they are still not easy to use.</p>
  </li>
</ol>

<h2 id="we-can-do-better">We can do better</h2>

<p>But we need not despair! We’ve repeately improved the usability of the tools by which we communicate with computers, from punchards and binary, to assembly, to Fortran, to C, to Python, to Haskell.</p>

<p>In fact, I believe that we can improve the usability of general programming to that of MIT’s Scratch, or Microsoft Office applications like Word, Powerpoint or Excel, or even a user-friendly application like Facebook.</p>

<p>However, there’s a mystery here: we haven’t made much progress on this front in decades. If improvement is possible, where is it? What are the barriers?</p>

<h2 id="i-started-working-in-2015">I started working in 2015</h2>

<p>I started working on this problem, developing programming languages prototypes, a few years ago. When I first began working on it, I thought I’d have the whole thing solved in just a matter of months. I was wrong.</p>

<p>While I did contribute some novel ideas to the space, I spent a lot of time retracing the steps of those that came before me. I learned the hard way that I need to read my history, learn about what others have done here.</p>

<h2 id="collaboration">Collaboration</h2>

<p>In the summer of 2017, I was approached by Irvin Hwang who suggested starting a NYC-based meetup group for people interested in the future of programming. I thought that was the dumbest idea I’d ever heard – why talk to other people when I could read Alan Kay papers in my room? But I went to the first meeting and it blew my mind wide open. I learned so much in that hour! It inspired my <a href="./journal">journal</a> which at the time became the core of my research project. After Irvin became busy with his new job, I took over the group that I originally thought was a waste of time. What a 180 degree turn!</p>

<p>It was also around this time that I began my <a href="./index.html">Future of Coding Podcast</a>, where I alternate each week between recapping my own research and speaking with experts. It’s been an incredibly valuable experience for me: 1) helping add structure to my research, 2) gain new insights through collaboration, 3) encourage me to reflect on my progress, and 4) give me energy as people respond to my episodes with exciement and ideas of their own.</p>

<h2 id="i-need-a-well-defined-goal">I need a well-defined goal</h2>

<p>While podcasting, journaling, reading papers, and playing with others’ prototypes are key to the success of this project, they are only valuable insofar as they move me closer to my main objective. So what is this objective?</p>

<h2 id="goal-make-computing-accessible-to-all">Goal: Make Computing Accessible to All</h2>

<p>I want to live in a world where every human can make their thoughts precise enough for machines to understand them.</p>

<p>There are two parts to this goal:</p>

<ol>
  <li>
    <p>Education. People need to learn to make their thoughts precise. This is often called “computational thinking.” Even with amazing programming environments like LOGO or MIT Scratch, it takes students hundreds of hours to develop the thinking proccesses to communicate their ideas with computers. That’s what my company The Coding Space is all about: providing an environment for students to learn computational thinking. This is to say, building an amazing tool is not enough.</p>
  </li>
  <li>
    <p>Tools. However, building an amazing tool is an enabler! The work done at The Coding Space would not be possible without the work of Seymour Papert on LOGO which inspired Mitch Resnick to create MIT Scratch. And the work I’ve done on WoofJS also enables our students to learn more than they could’ve without the tool.</p>
  </li>
</ol>

<p>Thus you need both education and tools. As I move away from working at The Coding Space, I am shifting my focus from education to tools because I see that as currently the main limiting factor.</p>

<p>Our curriculum in Scratch is wonderful. Kids learn computational thinking while making fun games. This wonderful curriculum is continued in WoofJS where students work on learning more valuable concepts while building more complex games. However, there are two related problems:</p>

<ol>
  <li>What do students do after they are done with WoofJS?</li>
  <li>What if students don’t want to make simple and silly games in Scratch or WoofJS? What if they want to create real applications to solve real problems? Why should they have to mess around in toy programming environments for a couple hundred hours before getting to “real coding”? And then once they get to real coding why must these students spend hundreds more hours learning “real coding”’s tools with such poor usability?</li>
</ol>

<p>Clearly what’s needed is <strong>a tool with the power of a general-purpose programming language with the usability qualities of a standard end-user application</strong></p>

<p>There are a few notable things missing from this goal which I want to make explicit:</p>

<ol>
  <li>
    <p>My aim is not to create a company. My aim is to produce a tool. If it seems like a company is the best way to accomplish this aim, so be it. However, I aspire to be able to create this tool outside of a traditional company structure, more like Linux or CycleJS.</p>
  </li>
  <li>
    <p>I don’t need to be the person who creates this tool. I will judge this project an unqualified success if it somehow inspires or informs the creation of this tool by someone else. Would I prefer to create it myself? Yes, that does seem fun. However, I aspire to not be sad if someone beats me to the punch. I aspire to give that person a metaphorical high five, and them move on to the next world-changing project on my to-do list.</p>
  </li>
  <li>
    <p>Yes, this goal is vague. I do not want to commit to what this tool will look like in its goal. You can read <a href="./priciples">my specific design priciples about what it may look like here</a>.</p>
  </li>
</ol>

<h2 id="constraints">Constraints</h2>

<ol>
  <li>
    <p>My time. Currently it’s limited to 20ish hours per week for this project. Over time I will increase this time as I decrease my commitmentes to other projects. However, as my work-life balance is important to me (and to the long-term sustainability of this project), I will have a maximum of 40ish hours per week here. Thus it is important both to 1) spend my time in a maximally useful way and 2) to leverage other people.</p>
  </li>
  <li>
    <p>Capital. While I do have enough capital to sustain myself working on this project indefinitely, I do not currently have the funds to sustain others. I wonder if this will become more of a blocker over time as I collaborate with others that need day jobs to pay the bills and what creative solutions we can come up with to overcome this.</p>
  </li>
  <li>
    <p>Knowledge. While I have been programming for a decade and developing programming languages for years now, there is still so much more for me to learn. It sometimes feels endless, because even as I gain appreciation for all the work that has been done before, it is impossible to stay astride of all the new innovations in the field that are being developed constantly. Filtering out the noise will become increasingly important.</p>
  </li>
</ol>

<h2 id="strategy">Strategy</h2>

<ol>
  <li>Articulate the goal</li>
  <li>Come up with a plan to achieve the goal</li>
  <li>Get feedback on the plan, and revise the plan accordingly</li>
  <li>Attack the plan</li>
  <li>Periodically reflect on how the plan has made progress towards the goal. If the goal has not been acheieved, return to step 2. If it has been achieved, pick another goal and return to step 1.</li>
</ol>

<p>I have the goal, and the strategy, so now I need a plan…</p>

<h2 id="the-plan">The Plan</h2>

<h3 id="what-i-know">What I know</h3>

<ol>
  <li>Code on github.</li>
  <li>Engaged developer community.</li>
  <li>Engaged user community</li>
</ol>

<h3 id="what-i-do-not-know">What I do not know</h3>

<ol>
  <li>Compile target</li>
  <li>Early use cases</li>
  <li>Early customers</li>
  <li>Interface / paradigm</li>
</ol>

<h3 id="endgame">Endgame</h3>

<ol>
  <li>Have an idea for a tool</li>
  <li>Begin prototyping it</li>
  <li>Test it out with users</li>
  <li>Iterate on it until it</li>
  <li>Get user traction</li>
  <li>Get contributor traction</li>
  <li>Manage its development until its ready to be passed onto someone else</li>
</ol>

<h3 id="how-should-i-balance-my-time">How should I balance my time?</h3>

<p>There are a few different activities I can do:</p>

<ol>
  <li>General research (like reading Alan Kay or Bret Victor)</li>
  <li>Working on a specific project (like reading Conal Elliot to learn about FRP for StreamSheets)</li>
  <li>Build a community (hosting meetups, connecting people, podcasting)</li>
  <li>High-level strategy (master planning like this)</li>
</ol>

<p>But at the end of the day, only (2) working on a specific project will lead to the endgame. Everything else is just a way to arrive at (2). So the way to get there faster is by both 1) increasing the amount and quality of ideas, and 2) increasing the speed at which we can invalidate bad ideas.</p>

<p>I should partake in (1) general research only when trying to come up with better ideas because we don’t have good ones to work on.</p>

<p>I’m not entirely clear how to think about (3) building a community, because while it won’t directly lead to me accomplishing the endgame, it will increase the odds that I inspire someone else to, which would also accomplish my goal. As a reasonable approximation, I want to spend ~10% of my time (or 4 hours per week) on this.</p>

<p>Finally, I am finding a lot of value in Master Planning in this way. I think I should reflect on my progress towards this plan weekly if not more often, but set aside special time to think more deliberately about it.</p>

<h2 id="prototype-options">Prototype Options</h2>

<h3 id="1-streamsheets">1. StreamSheets</h3>

<p>TODO LINK</p>

<h3 id="3-frp-woofjs">3. FRP WoofJS</h3>

<p>TODO LINK</p>

<h3 id="4-better-generic-interface-than-text">4. Better generic interface than text</h3>

<p>TODO LINK</p>

<p>Blocks, structured editor, flow diagram, spreadsheet interface, multiple representations (email guy)</p>

<h2 id="current-protoype-frp-woofjs-or-scratch">Current Protoype: FRP WoofJS or Scratch</h2>

<h3 id="fight-the-battle-with-one-interesting-front">Fight the battle with one interesting front</h3>

<p>With FRP WoofJS, I know the compile target (HTML canvas, JS, Elm, or CycleJS), early use case (games and animations), and early users (my students at The Coding Space). The only think I don’t know is the paradigm / interface for the tool.</p>

<h3 id="next-steps">Next steps:</h3>

<p>get Paul’s advice here, as well as Scott Mueller, Emmanuel Schnazer, and Christopher Anand.</p>

<p>read Conal Elliot, Ludcid, play with Elm, Pyret, Reflex</p>

<p>build a few toy apps</p>

<script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-103157758-1', 'auto');
ga('send', 'pageview');

</script>

<script repopath="stevekrouse/futureofcoding.org" type="text/javascript" src="/unbreakable-links/index.js"></script>

