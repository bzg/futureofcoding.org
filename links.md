---
title: Link Research
---

# Link Research

## To Research

### Streamsheets

* [Glen Flowsheets](https://tinyletter.com/Flowsheets/archive)
* http://elm-lang.org/blog/farewell-to-frp
* [CycleJS Component Difficulties](https://www.youtube.com/watch?v=CU8jtb6UBGg&feature=youtu.be&t=46m15s)
* [LINQ](https://www.linqpad.net/)
* http://conal.net/papers/icfp97/
* http://conal.net/papers/push-pull-frp/
* http://conal.net/papers/Eros/
* http://tinyletter.com/Flowsheets/
* https://www.learnrxjs.io/ and https://www.learnrxjs.io/operators/complete.html
* https://github.com/gelisam/frp-zoo
* https://github.com/reflex-frp/reflex
* making sure everything can be visual (pool, math.random) https://github.com/cyclejs/cyclejs/issues/581
* [Forms/3](http://web.engr.oregonstate.edu/~burnett/Forms3/forms3.html)
* [MIT Objective spreadsheets](https://sdg.csail.mit.edu/projects/objsheets) from Jaime Brandon
* [Dedalus](https://pdfs.semanticscholar.org/03dc/b87fb0e0d8cd9fa85b09035a98ba5f2c779e.pdf)
* [Lucid](http://worrydream.com/refs/Wadge%20-%20Lucid,%20the%20Dataflow%20Programming%20Language.pdf) - very important, says Glen Chiacchieri
* [query, datalog, logicblox](https://pdfs.semanticscholar.org/0ffa/f68f4399998864d6d9835c7bd8240d322b49.pdf) from Jaime Brandon
* https://en.wikipedia.org/wiki/Prograph
* https://noflojs.org/
* http://www.ragic.com/
* [Framer 3](https://www.producthunt.com/posts/framer-3)

### LogicHub

* [Michael Nielson](http://michaelnielsen.org/) - thinking and future of science from Future of programming meeting 10/2/17
* [TiddlyWikin](http://tiddlywiki.com/)
* https://github.com/raymestalez/nulis
* http://wagn.org/
* [Chorus](http://www.chorus-home.org/)
* [Ted Nelson Literary Machines](http://www.tcnj.edu/~robertso/readings/nelson-literary-machines.pdf) - from Glen Chiacchieri
* [As We May Think by Vanneevar Bush](https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/) - from Glen Chiacchieri

### Projectional / block based editors

* http://cs.wellesley.edu/~blocks-and-beyond/program.html
* http://kevinmahoney.co.uk/articles/structural-editor-prototype/
* [Max audio editing software](https://en.m.wikipedia.org/wiki/Max_(software))
* [Hazelnut](https://www.youtube.com/watch?v=99SRVnRA9Ec)
  * https://arxiv.org/pdf/1703.08694.pdf
* [General Principles for a Generalized Idea Garden](https://www.researchgate.net/publication/313369217_General_Principles_for_a_Generalized_Idea_Garden)
  * get back to Jonathan Edwards after reading this one!
* [Usability Analysis of Visual Programming Environments](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.815&rep=rep1&type=pdf)
* [A Module System for a General-Purpose Blocks Language](http://www.vpri.org/pdf/tr2015003_modsys.pdf)
* [ProseMirror](https://news.ycombinator.com/item?id=15465125)
* http://www.luna-lang.org/
* https://www.touchdevelop.com
* https://www.hyperpad.com/
* Thunkable
* https://powerapps.microsoft.com/en-us/
* Jet Brains MPS
* http://www.greenfoot.org/frames/
* http://flowlab.io
* http://embrio.io/
* http://harc.ycr.org/project/gp/
* http://www.andescotia.com/products/marten/

### Organization

* https://medium.com/open-collective/open-collective-v2-is-live-61b7cd3195e3


### Database for humans

* spend time with airtable -- heston says it's beautiful
* https://sheetsu.com/
* [Graphcool framework](https://blog.graph.cool/graphcool-framework-preview-ff42081b1333?gi=566b11413ea2)
* https://www.producthunt.com/posts/csvshare
* [Dear Postgres](http://www.craigkerstiens.com/2017/10/12/dear-postgres/)
* alpha sense, cap iq, sentieo (from Sarah's friend)

### ETL for humans

* http://juan.benet.ai/data/2014-03-07/format-conversion
* https://etleap.com/


### Explorable explainations

* [Nick Case](http://ncase.me/)
* https://essay.ink/ - by Omar Rizwan


### Mathland

* https://www.khanacademy.org/research/reports/early-math - from Omar Rizwan
* https://www.khanacademy.org/research/reports/cantor - from Omar Rizwan
* https://www.khanacademy.org/research?t=projects - from Omar Rizwan
* http://ife.ens-lyon.fr/publications/edition-electronique/cerme6/wg4-11-haspekian-bruillard.pdf
* https://www.researchgate.net/publication/295403503_Behind_students'_spreadsheet_competencies_their_achievement_in_algebra_A_case_study_in_a_French_vocational_school


### Random 

* http://alan-kay.wikia.com/wiki/Alan_Kay_Wiki - from Glen Chiacchieri
* [DynamicLand Zine](https://www.dropbox.com/s/68cu6ztvpgmwnsa/dynamicland.pdf?dl=1) - from Glen Chiacchieri
* main competitor to bubble.is: http://www.configure.it/
* https://www.froala.com/pages (design web pages with blocks, looks similar to Universe or webflow)
* http://ravichugh.github.io/sketch-n-sketch/ (similar to aprt.us)
* http://mgrf.de/vogo/ (looks similar to aprt.us)
* https://building.onuniverse.com/
* https://nextjournal.com/dubroy/ohm-parsing-made-easy
* [Nicky Case - LOGO with english](https://twitter.com/ncasenmare/status/919219174311911424)
* [HN:	Clojure/Conj 2017 – Opening Keynote by Rich Hickey [video]](https://news.ycombinator.com/item?id=15464423)
* [TOby Schachman's Shadershop](http://tobyschachman.com/Shadershop/)
* watch videos of yahoo pipes and hypercard - from Glen Chiacchieri
* [Desigining to reveal the nature of the universe Jonathan Blow](https://www.youtube.com/watch?v=OGSeLSmOALU) - from Glen Chiacchieri
* [Natalie Rusk](https://en.m.wikipedia.org/wiki/Natalie_Rusk) - written by Glen Chiacchieri
* [ObservableHQ](https://observablehq.com/) - similar to iPython Notebook from Glen Chiacchieri
* [Programming Models for Distributed Computation](https://github.com/heathermiller/dist-prog-book/blob/master/README.md)
* [Real-Time Programming and the Big Ideas of Computational Literacy](https://llk.media.mit.edu/papers/ch-phd.pdf)
* [Sapir–Whorf hypothesis](https://en.wikipedia.org/wiki/Linguistic_relativity) langauge affects thoughts- from @curious_reader
* [A Whole New World](https://www.destroyallsoftware.com/talks/a-whole-new-world) - from @curious_reader
* [Useing You're Type's Good](https://www.destroyallsoftware.com/talks/useing-youre-types-good) - from @curious_reader
* [Bondaries](https://www.destroyallsoftware.com/talks/boundaries) - from @curious_reader
* [IPFS](https://ipfs.io/) - from @curious_reader
* [A collection of the thoughts of people like Bret Victor, Ted Nelson, Alan Kay and other programming luminaries of our generation](https://github.com/andytudhope/APerspectiveOnTechnology) - from @curious_reader
* [Final STEPS report hacker news discussion](https://news.ycombinator.com/item?id=11686325)
* Read [Runar's blog](http://blog.higher-order.com/blog/archives/), especially [his first post](http://blog.higher-order.com/blog/2008/12/04/no-such-thing/) - from @curious_reader
* [Programming and Scale - Alan Kay](https://www.youtube.com/watch?v=YyIQKBzIuBY) - from @curious_reader
* [Whats Functional Programming All About](http://www.lihaoyi.com/post/WhatsFunctionalProgrammingAllAbout.html#what-functional-programming-is-not)
  * TODO read this
  * This article is amazing! LOVE the sideways recipie thing to explain the distinction between declarative and sequential! I had trouble with this idea before this article.
* [Sourced.tech](http://sourced.tech/) - machine learning trained to generate source code (from Aaron Kent)
* [What Should Follow The Web](https://blog.plan99.net/what-should-follow-the-web-8dcbbeaccd93)
* [Words Matter](https://existentialtype.wordpress.com/2012/02/01/words-matter/) - from Paul Chiusano
* [Dynamic Languages are Static Languages](https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/) - from Paul Chiusano
* [Pete Hunt - past, present, and future of ReactJS](https://tech.lendinghome.com/pete-hunt-the-past-present-and-future-of-react-5b47acbf42b) - at Lending Home (from Matt Marcus)
* [It's time to kill the web](https://blog.plan99.net/its-time-to-kill-the-web-974a9fe80c89)
* [WebTask](https://webtask.io/) - similar to webscript.io & clay.run (from Nicolae Rusan)
* [Node playground](https://runkit.com/home) - similar to iPython notebook or TryCarbide (from Nicolae Rusan)
* [Babelfish - from Aaron Kent](https://blog.sourced.tech/post/announcing_babelfish/)
* [CS and Literature - from @curious_reader](https://twitter.com/curious_reader/status/908954000501952512)
* [Blockchains for a Better World - from @curious_reader](https://twitter.com/curious_reader/status/908391783901663232)
* [Dan Scanlon's Fractal](https://github.com/danscan/fractal) and [video](https://www.youtube.com/watch?v=wtoPXsadpQI&feature=youtu.be)
* [Alan Kay HN AMA](https://news.ycombinator.com/item?id=11939851)
* http://elevr.com/elevr-leaving-ycr/
* [Joe Edelman - citizen logisitics](http://nxhx.org/) and [Chatterbase](http://alpha.trycarbide.com/@jxe/6d5e19369ddb9cc4728510e11a3f7586)
* http://explorabl.es/reading/
* http://nxhx.org/
* [anima - Or Arbel](http://www.animaapp.com/)
* https://idyll-lang.github.io/
* Inmates are running the Asylum
* Hacker's Delight
* [On Abstraction - Zach Tellman](https://m.youtube.com/watch?v=x9pxbnFC4aQ) from dan scanlon 
* [New Etoys](http://www.vpri.org/fonc_wiki/index.php?title=New_Etoys)
* [Alan Kay Videos](http://www.vpri.org/html/words_links/links_ifnct.htm) 
* Lively Kernal https://harc.ycr.org/project/lively/
* http://cs.wellesley.edu/~blocks-and-beyond/
* HyperCard
* Vi Hart
* [code.world](https://code.world/#PgOPqtxOVsfDQJe7-GkGdnQ)
* [SKETCHPAD A MAN-MACHINE GRAPHICAL COMMUNICATION SYSTEM - Sutherland](https://www.cs.purdue.edu/homes/hosking/197/canon/sutherland.pdf)
* look into heap analytics for its similarity to streamsheets (from Joe West)
* research moon script and the indie game community as it pertains to influencing WoofJS (joe west reccomended this)
* [Data-Oriented Design by Richard Fabian](http://www.dataorienteddesign.com/dodmain/)
* [Stencil – A reusable web component generator](https://news.ycombinator.com/item?id=15080174)
* [http://digitalfreepen.com/2017/08/16/elixir-in-depth-notes.html](http://digitalfreepen.com/2017/08/16/elixir-in-depth-notes.html)
* [John Carmack's keynote at Quakecon 2013 part 4](https://www.youtube.com/watch?v=1PhArSujR_A)
* [Maude](https://www.youtube.com/watch?v=mZE_Xv9qym4), which comes highly reccomended by Ezekiel Smithburg from the Future Programming Slack.
* http://worrydream.com/substroke/
* [ICFP 2012. Roly Perera: Functional Programs that Explain their Work.](https://www.youtube.com/watch?v=pqtqaL_ojpk&feature=plcp)
* [Pacific Northwest Scala 2013 We're Doing It All Wrong by Paul Phillips](https://www.youtube.com/watch?v=TS1lpKBMkgg)
* Furure of Programming Workshop - http://www.future-programming.org/
* http://www.kenperlin.com/
* http://harc.ycr.org/flex/
* http://alpha.trycarbide.com/
* Kite.com
* PureScript
* [Dijkstra's diary](http://www.cs.utexas.edu/users/EWD/indexChron.html) - from @curious_reader
* @curious_reader's repo on gitlab
* [@mrb_bk](https://twitter.com/mrb_bk) - from @curious_reader
* https://elixir-lang.org/
* http://www.eff-lang.org/
* https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/TFM.pdf
* Idris
* http://shaunlebron.github.io/parinfer/
* https://www.sourcetrail.com/
* http://www.clickteam.com/multimedia-fusion-2
* Unity
* https://www.scirra.com/construct2
* https://www.pipes.digital/
* [Tulip](https://www.youtube.com/watch?v=lvclTCDeIsY)
* https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/
* http://www.memex.org/licklider.pdf
* http://web.media.mit.edu/~minsky/papers/TuringLecture/TuringLecture.html
* [Computer as Communications Device](https://www.dropbox.com/s/4td8aj5gglf4qfj/The%20Computer%20As%20A%20Communications%20Device.pdf?dl=0)
* http://www.red-lang.org/p/about.html
* https://cospaces.io/edu/
* [Seymour Papert On Logo](http://el.media.mit.edu/logo-foundation/resources/onlogo/index.html)
* [Type Systems for Beginners](https://gilbert.ghost.io/type-systems-for-beginners-an-introduction/)
* [Types, Logic, Semantics, and Verification](https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html)
* reasonML
* http://conal.net/blog/posts/reimagining-matrices
* https://www.linkedin.com/pulse/programming-languages-future-coding-chris-grimes
* [Petri net](https://en.wikipedia.org/wiki/Petri_net) - from Wila
* [Exploding Dots](https://www.explodingdots.org/) - from Rufus

## Researched

### Bret Victor Deep Dive

* [Bret Victor UGCS](http://worrydream.com/ugcs)
  * "calltech was best four years of my life", but UC Berkley was "hell"
  * "I'm a passive pacifist. Like an apolitical Gandhi with food and hair."
  * "My Ultimate Life Goal is, basically, to Create Something Good. To invent something that improves the state of the world. Something that helps people, something that improves the global quality of life. Something. Someday."
  * "I like getting e-mail. Send some to bret@ugcs.caltech.edu. Please?" Seems like this changed.
  * "The Inmates Are Running the Asylum: This book should be required reading for everyone in or around the software industry. Nothing I've read has ever resonated with me this strongly." TODO add this to the top of the list
  * Hacker's Delight: Despite the cringingly misleading title, this is the best book ever written. I'm in rapture. TODO add this to the top of the list as well.
  * I'm really enjoying reading his blog from when he, like me now, was 23. Sounds like he was trying to find his way, post-hell-grad-school, and post-break-up with Joanne (which is heartbreaking).
  * TODO continue reading his blawg after 5/11/01.


* [Clay](https://www.clay.run/)
  * built this: https://www.clay.run/services/steve/github-project-data/code
  * chatted with Nicolae about the type signature of the functions and he's been iterating on that, which has been cool to watch

* [Mesh Preview](http://chrispsn.com/mesh-preview.html)
  * his main thesis is excel doesn't treat rows as arrays, but you can fix that by dropping location-based referencing (which I also agree with... I think that refering to a cell as A4 is Exel's version of C pointers.)


* [Mesh Announcement Notes](http://chrispsn.com/mesh-announcement-notes.html)
  * [Racket 2D Syntax](https://news.ycombinator.com/item?id=14824217) is neat (and very very similar to [stream-tree](https://github.com/Widdershin/stream-tree))
  * HOLY CRAP the [Java Stream Debugger](https://plugins.jetbrains.com/plugin/9696-java-stream-debugger) he links to is super relevant for me. Stream visualization!

* https://github.com/staltz/cycle-onionify
  * https://staltz.com/unidirectional-user-interface-architectures.html
  * really neat, powerful, and simple (with just 150 LOC) architecture. I'll have to build something in it eventually to get a better sense for it, and how it'd fit into StreamSheets. It might be impossible...


* [Andre Staltz: The Past, Present, and Future of Cycle.js. Part I – CycleConf 2017](https://vimeo.com/216787869)
  * fun to see the whole history of how he came to CycleJS through intuition
  * crazy to see how collaborative this project is! Makes me glad I'm now a supporter.
  * Great talk, very informative. I wouldn't have needed to chat with Andre as much if I had just found this video (which I almost did, because I did find the slides for this talk)
  

* [Andre Staltz: The Past, Present, and Future of Cycle.js. Part II – CycleConf 2017](https://vimeo.com/216975979)
  * wow, this talk is great, and is basically like his "thesis" on what programming is and how to improve it
  * [vimeo playback speed increase chrome extension is KILLER](https://chrome.google.com/webstore/detail/vimeo-repeat-speed/noonakfaafcdaagngpjehilgegefdima/related?hl=en) 
  * He's really into Luna
  * He is into the [Koka langauge](https://koka-lang.github.io/koka/doc/kokaspec.html), particularly how they use familiar dot-notation to represent functional calls
  * "Languages are for life" --> 10 year project. Huge commitment. Getting married. I want to do this so bad!
  

* https://github.com/Widdershin/bonsai-editor
  * it's like stream-tree but with a GUI. drag and drop editor for dataflow diagrams
  * first version was with mouse-controls, but now working on keyboard shortcuts
  

* https://github.com/Widdershin/stream-tree
  * write application by writing an ASCI graph, which turns in JS code
  

* https://medium.com/open-collective/cycle-js-a-unified-theory-of-everything-for-javascript-e266ac9a59ad
  * [convinced me to support on open collective!](https://twitter.com/stevekrouse/status/908773352873037826)
  

* [Nick Johnstone: The Hitchhiker’s Guide to Cycle.js – CycleConf2017](https://vimeo.com/217444733)
  * Great story about doing time travel, hot reloading, collaborating with Andre 
  * Gotta send him an email TODO

* [Chris Granger Eve at Strangeloop 2015](https://www.youtube.com/watch?v=5V1ynVyud4M)
  * Holy crap Andre Staltz was right! I really needed to re-watch this video. It's almost identical to my pitch for StreamSheets.
  * They explain how they came to datalog from the Berkley BLOOM project
  * They have a spreadsheet like interface but stuck to a text-based datalog interface to speed up prototyping (but in my opinion CycleJS is the real text-based prototype of this)
  * However, they did try doing it with a spreadsheet GUI thig! Even an HTML WYSIWYG with layers!
  * When trying to explain queries to each other, they drew diagrams for them (sounds like CycleJS dataflow diagrams)


* [isomorf.io](http://isomorf.io/)
  * [live tour](https://isomorf.io/#!/tour)
  * [blog](https://medium.com/isomorf-blog)
  * [Debate about projectional editors](https://www.reddit.com/r/programming/comments/6zhwwl/projectional_programming_rnosyntax/) from Aaron Kent
  * [An Experiment in Structured Code Editing](https://lobste.rs/s/ofx5mf/experiment_structured_code_editing) from Aaron Kent
  * [Call with Aaron Kent](./notes/aaron-kent-call-9-15-17)


* [Computer Software - 1984](http://www.vpri.org/pdf/tr1984001_comp_soft.pdf)
  * "A powerful genre can serve as wings or chians. The most treacherous metaphors are the ones that seem to work for a time, because they can keep more powerful insights from bubbling up."
    * TODO think about these, particularly about progrmming, but also other fields
  * "The computer field has not yet had its Galileo or Newton or Bach or Beethoven, Shakespeare or Moliere. What is needs first is a William of Occam... Just how many concepts are there really [in computer software]? And how can metaphor, the magical proccess of finding similarity and even identiy in diverse structures, be put to work to reduce complexity?"
  * "In algebra, the concept of the variable, which allows an infinity of instances to be represented and dealt with as one idea, was a staggering advance."
  * ![screenshot 2017-09-01 at 5 17 22 pm](https://user-images.githubusercontent.com/2288939/29988090-7c39ce56-8f39-11e7-87d3-0e52541d1978.png)
    * "Dynamic spreadsheets were invented by Daniel Bricklin and Robert Frankston..."
    * It's crazy how much this picture reminds me of StreamSheets, which was largely inspired by an Alan Kay talk
  * "Users must be able to tailor a system to their waints. Anything less would be as absurd as requiring essays to be formed out of paragraphs that have already been written."
  * ![screenshot 2017-09-01 at 5 34 25 pm](https://user-images.githubusercontent.com/2288939/29988517-e81e1ad0-8f3b-11e7-8331-ea5f84985819.png)
    * A really wonderful discourse on "computer literacy" that reminds me a lot of Chris Granger's "Coding is not the new literacy"

* [The Power Of The Context - 2004](http://www.vpri.org/pdf/m2004001_power.pdf)
  * "About 10 years ago I wrote a history paper about our group's research (available online: see references below) and found, even in 60 pages, I could not come close to mentioning all the relevant influences. This is because I've long been an enthusiastic appreciator of great ideas in many genres—ranging from the graphic, musical and theatrical arts to math, science and engineering."
    * TODO read this history 
  * "My interest in children's education came from a talk by Marvin Minsky, then a visit to Seymour Papert's early classroom experiments with LOGO. Adding in McLuhan led to an analogy to the history of printed books, and the idea of a Dynabook metamedium: a notebook-sized wireless-networked "personal computer for children of all ages". The real printing revolution was a qualitative change in thought and argument that lagged the hardware inventions by almost two centuries. The special quality of computers is their ability to rapidly simulate arbitrary descriptions, and the real computer revolution won't happen until children can learn to read, write, argue and think in this powerful new way. We should all try to make this happen much sooner than 200 or even 20 more years! This got me started designing computer languages and authoring environments for children, and I've been at it ever since. "
  * "The Smalltalk system that I designed, and Dan Ingalls implemented, used an important meta-idea from LISP that allowed its DNA to be completely described on one sheet of paper, implemented in a month, and then grown in the presence of experience and new ideas into the powerful system it became. "
  * Before this article, I thought Seymour Papert and Alan Kay had a baby and it was Mitch Resnick and Scratch. Now I see that it is much more linearly Papert -> Kay -> Resnick.
  * 'it is amazing to me that most of Doug Engelbart's big ideas about "augmenting the collective intelligence of groups working together" have still not taken hold in commercial systems.'
    * TODO look this up
  * TODO organize and pull many of the resources in the notes from this paper into this list of links.

* [The Early History Of Smalltalk](http://worrydream.com/EarlyHistoryOfSmalltalk/)
  * "Small minds try to form religions, the great ones just want better routes up the mountain. Where Newton said he saw further by standing on the shoulders of giants, computer scientists all too often stand on each other's toes. Myopia is still a problem where there are giants' shoulders to stand on—"outsight" is better than insight—but it can be minimized by using glasses whose lenses are highly sensitive to esthetics and criticism."
  * "Programming languages can be categorized in a number of ways: imperative, applicative, logic-based, problem-oriented, etc. But they all seem to be either an "agglutination of features" or a "crystallization of style." COBOL, PL/1, Ada, etc., belong to the first kind; LISP, APL— and Smalltalk—are the second kind. It is probably not an accident that the agglutinative languages all seem to have been instigated by committees, and the crystallization languages by a single person."
  * "Smalltalk's design—and existence—is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages. Philosophically, Smalltalk's objects have much in common with the monads of Leibniz and the notions of 20th century physics and biology. Its way of making objects is quite Platonic in that some of them act as idealizations of concepts—Ideas—from which manifestations can be created. That the Ideas are themselves manifestations (of the Idea-Idea) and that the Idea-Idea is a-kind-of Manifestation-Idea—which is a-kind-of itself, so that the system is completely self-describing— would have been appreciated by Plato as an extremely practical joke."
  * "Though OOP came from many motivations, two were central. The large scale one was to find a better module scheme for complex systems involving hiding of details, and the small scale one was to find a more flexible version of assignment, and then to try to eliminate it altogether. As with most new ideas, it originally happened in isolated fits and starts.""
    * TODO think more on "hiding details", local variables, abstractions and leaks, etc.  
  * "we want an apparently free environment in which exploration causes desired sequences to happen (Montessori); one that allows kinesthetic, iconic, and symbolic learning—"doing with images makes symbols" (Piaget & Bruner); the user is never trapped in a mode (GRAIL); the magic is embedded in the familiar (Negroponte); and which acts as a magnifying mirror for the user's own intelligence (Coleridge)."
  * "One way to think about progress in software is that a lot of it has been about finding ways to late-bind, then waging campaigns to convince manufacturers to build the ideas into hardware. Early hardware had wired programs and parameters; random access memory was a scheme to late-bind them. Looping and indexing used to be done by address modification in storage; index registers were a way to late-bind. Over the years software designers have found ways to late-bind the locations of computations—this led to base/bounds registers, segment relocation, page MMUs, migratory processes, and so forth. Time-sharing was held back for years because it was "inefficient"— but the manufacturers wouldn't put MMUs on the machines, universities had to do it themselves! Recursion late-binds parameters to procedures, but it took years to get even rudimentary stack mechanisms into CPUs. Most machines still have no support for dynamic allocation and garbage collection and so forth. In short, most hardware designs today are just re-optimizations of moribund architectures."

* [The Center of "Why?" - 2004](http://www.vpri.org/pdf/m2004002_center.pdf)
  * "Still later when I lucked into a terrific grad school at the University of Utah, my first thought was that this was just like 4th grade! And then I realized that Mary Quirk had made 4th grade just like a great graduate school! This is a critical insight. Children are in the same state of not knowing as research scientists. They need to go through many of the same processes of discovery in order to make new ideas their own. Because discovery is really difficult and has taken hundreds of years, the difference is that children have to be scaffolded carefully (but not using the Socratic method, it "leads the witness" too much). Instead the scaffolding has to be set up as close encounters and careful but invisible sequencing to allow the children to make the final leaps themselves. This was the genius of Mary Quirk. It was interesting that we never found out what she knew. She was focused on what we knew and could find out."
  
* ["End-User to the Metal" Personal Computing - Proposal to NSF Granted on August 31, 2006](http://www.vpri.org/pdf/rn2006002_nsfprop.pdf)
  * "We want to be able to do what applications do (and more), but, as with "operating systems", we think there are better paths than the traditional annoying stovepipes that give rise to a few proprietary objects in a way that makes it difficult to combine. Something more like a desktop publishing system that could allow any and all objects to be freely combined visually and behaviorly would be much better. Just as a DTP system allows many different visual elements to be formatted in a wide variety of ways (and master templates made to capture the most useful forms) to cover the entire space of user documents, we would like to go farther in this direction to cover all of the end-user’s needs with a single notion of objects, graphics, user interface, publishing and search. One metaphor that might help (and was an inspiration for many of these ideas) is "HyperCard on Steroids." To do this one would extend HyperCard to have any number of useful objects, allow all to be scripted, and allow the hyperCards to be both full-fledged media pages for docs, web, and presentations, etc., and to recursively be its own embedded media objects."
  *  A newer idea that is moving towards the mainstream is that specifications should be executable and debuggable. We want to go even further to "ship the specifications" – that is, the specifications should not just be a model of the meanings in a system, but should simply be the actual meanings of the systems. This leads to a corollary idea: that we should have an absolute separation of meanings from optimizations" 

* [Inventing Fundamental New Computing Technologies](http://www.vpri.org/html/work/ifnct.htm)
  * "Code is too: large, complex, costly, buggy, insecure, segregated, and inexpressive."
  * Using the ideas of better abstractions from math to better expression software ideas to compress the amount of code it takes to build a complete software system. This idea feels both beautiful and unneccesary from the perspective of my beautiful $250 chromebook. At the same time, I probably don't even see the ways in which not being able to inspect the chrome code (which I could in theory inspect but in practice is too complex) holds me back. Given my repulsion to low level software, I don't really mind shooting for the web as my compile target. The only caveat here is Pete Hunt and my discussion about creating a new HTML/CSS layout and style engine on the canvas to replace HTML and CSS.
  * Interesting how the focus here is not on reinventing computing but on reinventing the fundamentals to *enable* that revloution to happen. It's almost like Alan Kay is going back to do things right this time, after he wasn't able to build SmallTalk/Dynabook the way he wanted to the first time.

* [Alan Kay - Education 22nd Century](https://www.youtube.com/watch?v=R1R2jH4PQEo&feature=youtu.be)
  * The fact that we teach sorting in comptuer science classes is a joke! These problems have all been solved! It's a total lack of imagination. TODO make a list of all these silly things in standard college CS education.
  * You don't want a computer system that just gives kids the answer because that's like having a servent that does everything for you. I think this is a super fine line. What about the sorting example from above? I think the answer to this question is precision and expressivity and customizability. If a system can do whatever the student wants, then make it as easy as you can. Where you get into trouble is when the system is to set in its ways to do anything interesting, such as "click this 1 button to make flappy bird." This is why adding more police stations in Sim City as the only way to reduce the crime rate is ridiculous.
  * He has an idea for "a list of powerful ideas for children to become fluent in". He wants to collect a list of these ideas and then map backwards, thinking about the sorts of tool and programming languages we need in order to make this possible. Let me give it a try: top-down programming, debugging, iteration, version control, thinking about definitions, rules of inference, systematic human biases, deliberate practice, writing (journaling), universiality of computation, criticism, non-violent communitcation, modeling, variables, derivates, limits, systems, emailing... Ok, some of those are not like the others... but you get the idea.

* [Alan Kay - Computers, Networks and Education](http://www.vpri.org/pdf/sci_amer_article.pdf)
  * students are "fed the menu", because "the representation of ideas have replaced the ideas themselves"
  * List of misconceptions about learning: "empty vessel", "bitter pill to sugarcoat", "innate intelligence", "cohesive self", not understanding how the more mental models you have, the easier it is to assimilate new models, not understanding "the medium is the message", the belif that "some skills are more fundamental to others", the belief in a "minimum set of knowledge that make up a discipline", the belief in "being behind or ahead or on track", the goal of "getting into college / getting a job", "pre-loaded learning vs just-in-time learning", "learning as resume building instead of for instrinsic learning", not recognizing the "importance of context (and emotions) in learning", "some people are 'math people' and some are 'arts people'"... TODO write more about this
  * "One could even argue that the educational approach in the classroom is not nearly as importnat as the set of values about learning found in the home." That's why we need to work on communicating the misconceptions found above to parents! 
  * He quotes John Holt! "Math and science would probably be learned better if they were made illegal"
  * A great quote by Philip Morrison that explains why LogicHub is needed: "This is why is is the eveidence, the experience itself and the argument that gives it order, that we need to share with one another, and not just the unsupported final claim."

* [Alan Kay - The Real Computer Revolution Hasn’t Happened Yet - 2007](http://www.vpri.org/pdf/m2007007a_revolution.pdf)
  * It takes so long to produce the right kind of teacher. I guess the way to go about it is take someone with a lot of the right stuff and then have lots of on-the-job training over lots of time (similar to what we do at TCS).
  * "the most important process in helping anyone learn how to do mathematical thinking is to put them in many situations in which they can use how they think right now in a more careful way"
  * Much of the philosophical gold in science is to be found in this noticing activity." TODO write about the key "powerful ideas" in science, as well as math, and the anti-lessons in the way we teach them now. One such idea is "measurement/tolerance"
  * Jefferson quote: " if we think them [the people] not enlightened enough to exercise their control with a wholesome discretion, the remedy is not to take it from them, but to increase their discretion by education"


* [STEPS 2007](http://www.vpri.org/pdf/tr2007008_steps.pdf)
  
* [STEPS 2008](http://www.vpri.org/pdf/tr2008004_steps08.pdf)

* [STEPS 2009](http://www.vpri.org/pdf/tr2009016_steps09.pdf)

* [STEPS 2010](http://www.vpri.org/pdf/tr2010004_steps10.pdf)

* [STEPS 2011](http://www.vpri.org/pdf/tr2011004_steps11.pdf)
  * "NoOS = No Operating System" 

* [KScript and KSWorld: A Time-Aware and Mostly Declarative Language and Interactive GUI Framework ](http://www.vpri.org/pdf/tr2013002_KSonward.pdf)
  * I can't believe my luck. This paper seems to have the same exact goals and incredibly similar methods to StreamSheets: reactive functional programming, dictonary objects, streams, late-bound variable resolution (this "loose coupling" seems like a bad idea given the importance of types but I guess it allows for more dynamic systems), GUI framework called KSWorld, Universal Document Editor called Frank
  * HyperCard "stack model", "Etoys authoring", "dissolve the barrier between system-defined and user-defined widgets"
  * "behaviors" (continuous values over time) vs "events" (sequence of discrete values) - they are basically the same thing from different angles
  * they solve the circular dependency problem between streams with an imperative `set` function. That seems sub-optimal. I wonder how CycleJS handles such circuluar dependencies, such as typing text into a text field changes the visible area of the text, which updates the knob in the scroll bar, but also when the user moves the knob of the scrollbar, that should update the visible area of the text field. Sounds like a difficult thing to solve abstractly in one's head but could be possible with a StreamSheets like interface.
  * You can refer to the previous value of a stream with an apostrophe so that you can define something as a "deritive", such as nat <- 0 followedBy nat' + 1. 
  * The graphical framework steals ideas from Morphic, Lessphic, and Tweak.
  * While many things in this langauge are reactive streams, it seems like you can also modify values imperatively, which doesn't feel right. It's not pure enough for the stream metaphor to be truly powerful. "It might seem appealing to write a layout as a set of dependency relationships between Boxes’ bounds streams, but since a typical layout specification involves relationships that are multi-directional, the dependencies would tend to become circular. Therefore we use procedural code for this part of the framework too." This seems unreasonable to me. Either streams are your core data structure and you commit to them fully or you give up on them entirely. I don't see how you can straddle the line like this. Curious what Andre (and the writers of this paper) would say to this criticism.
  * When a user wants to directly manipuate an object, they put a "halo" around it which disables all of the reactive events on that object so you can play with it (like "inspect element" in the browser)
  * I don't understand how this code sets up the buttonDown event: `buttonDown <- eventStream()`. Is the name of the stream on the left, `buttonDown` somehow influencing the types of events pulled out of the `eventStream()` on the right? That's the only thing I can imagine because all the streams are defined this way, such as `buttonUp <- eventStream()`. "To create a value stream that acts as an event (thus not having an initial value), the 0-ary function `eventStream()` is used."
  * There's a whole lot of the `this` keyword, which you'll not find a single instance of in Elm or CycleJS.
  * I am struck by how few lines of code, just a few thousand, it takes for them to represent an entire box, layout model, and FRP event engine. This makes me think that doing this project on the web could be trivially easy. In many ways similar to morphicJS. However with the few hours I spent exploring the morphicJS code, I'd aspire to have more managable code, preferably by having less (or no) code in text but most (or all) code built in a previous version of the very tool itself!
  * I could also look into [Dedalus](https://pdfs.semanticscholar.org/03dc/b87fb0e0d8cd9fa85b09035a98ba5f2c779e.pdf) (which doesn't have `set`) and [Lucid](http://worrydream.com/refs/Wadge%20-%20Lucid,%20the%20Dataflow%20Programming%20Language.pdf) which doesn't have the distinction between continuous and discrete streams (and which Bret Victor hosts!) and [Forms/3](http://web.engr.oregonstate.edu/~burnett/Forms3/forms3.html)


* [Making Applications in KSWorld](http://www.vpri.org/pdf/m2013003_ksapps.pdf)
  * seems like Flapjax is quite similar to CycleJS in some ways (less pure though)
  * Given how similar in design and goals this system is to StreamSheets, I'm wondering what would've happened if they built it like StreamSheets exactly. The thing I'm realizing is that the more generalized I make Streamsheets (just a dataflow programming tool), the more useful and expressive it can be. If it's just for creating HTML UIs it can be less exiciting possibly. On the other hand, NoFlo exists and it's trying to be a generalized dataflow langauge. I'm going to want to spend a whole day with that, like Eve. (And like Eve, I get the sense that it's going to be a fustrating day with a buggy tool.)
  * I like the "be something" menu name, such as "be a button", "be a slider", "be a line of text". As opposed to "inherit from the button class", which normally plagues OOP.
  * Making things "scrollable", is not nearly so neat, which speaks to a lacking of multiple-inheritance in their model.
  * In fact, there's a lot of code going on here, where their could be a UI type of thing, which is understable as this is just a research project.
  * I do find beauty in how their architecture of everything-is-a-box-that-is-always-editable makes it super easy to build a document editor. The system itself is basically already a document editor. This sounds a lot like how I imagine HyperCard to be, and how Paul Chuisano describes the future of apps. One thing to mention, however, is how turned off I am by the look and feel of the SmallTalk or LivelyKernal or KSWorld environment. It feels very gimicky and old-school and self-contained. TODO think about why it gives off that feeling (is it just that the colors and styles are ugly?) and how to combat that.
  * I can't stop laughing that in one of their examples is the phrase "What is Science?" which happens to be very similar to the title of a book I'm currently reading. I really have a lot in common with these guys, which is no surpise given that I was shaped by Logo, Scratch, Bret Victor and Alan Kay over the last decade.
  * It is quite exciting to learn that they built much of this system in a few thousand lines of code! With the right abstractions and goals in mind, you can really do a lot quickly!


* [STEPS 2012](http://www.vpri.org/pdf/tr2012001_steps.pdf)
  * I decided to start with the final report and see if I can get away with skipping the prior year updates for now...
  * As you can see above, I did read Apendix I and II before continuing with this paper, which was quite fun as they have an uncany relationship to my current protoype idea, StreamSheets.
  * All the Maru and NILE stuff go right over my head and I don't want to take the time now to investigate. Suffice it to say that if I ever want to "build beautiful abstractions all the way down to the metal", this is the place to look.
  * They end up using Bloom and Datalog (Dedalus) in service of seperating the "what" from the "how" of programming. It's interesting to see the same research pop up everywhere!
  * People clearly want to use the language best suited for a task to do that task. Thus enabling the stitching together of DSLs seems like a good way to go (although this is sometimes a pain to learn all someone else's DSL instead of building it up yourself unless it's a really good DSL), and thus the LISP macro system (or the Ruby DSL system) seem to shine here.
  * I wonder what work has been inspired/influenced by this work and if it is continuing in some form.


* [Alan Kay - User Interface - 2001](http://www.vpri.org/pdf/hc_user_interface.pdf)
  * When McLucan said "the medium is the message", "he meant that you can to *become* the medium if you use it" so that the "internalized" medium "can be subtracted out to leave the message behind." McLuhan: "I don't know who discovered water but it wasn't a fish."
  * TODO read *Towards a Theory of Instruction* (which I already had on my bookshelf, so I moved it to my nightstand)
  * TODO read "an inner game of tennis" (just bought on audible)
  * This article is mostly about [how humans have three seperate systems, enactive (know where you are, maipulate), iconic (recognize, compare, configure, concrete), and symbloic (tie together long chains of reasoning, abstract), and culmiates in his slogan "doing [mouse, enactive] with Images [icons, windows, iconic] makes Symbols [Smalltalk, symbolic]"](https://user-images.githubusercontent.com/2288939/30118214-73d7fe12-92f0-11e7-9185-f2a58c8841fb.png)
  

* [Programming and Programming Languages - 2010](http://www.vpri.org/pdf/rn2010001_programm.pdf)
  * Looking at all this EToys inspired me to find this thread http://forum.world.st/Why-is-Scratch-more-popular-than-Etoys-td3787377.html
  * He draws a comparison between mathmatics and programming language to better help explain programming languages, but it's useful to me in the opposite way. I think it would be neat if mathmatics used the terminology of "langauge" to explain why so many different sets of notation exist. For example, maxwell's equations, or even e=mc2. Are they the same as the algebra I learned in middle school? I know the calculus is not because there are new symbols.

* [Worlds: Controlling the Scope of Side Effects - 2011](http://www.vpri.org/pdf/tr2011001_final_worlds.pdf)
  * This is my second reading of this paper (skimming this time)
  * Seems like a reasonable idea. Reminds me of the singleton-state of the Flux "control pattern"
  * I think I'm convinced: having "implicit scope" is bad. If you want something on the global object, you should specify it (this becomes less of a typing problem in a structured editor). This is good because 1) it makes scope more understandable, 2) it makes variable declaration and object-key assignment unified, and 3) it allows global state to be a first-class object, not some special object.
  * I'm not sure I'm 100% convinced of the git-like branching and committing workflow. Seems a little over the top in some ways, but I do like how it gives you "undo for free".


* [The Future of Reading Depends on the Future of Learning Difficult to Learn Things - 2013](http://www.vpri.org/pdf/future_of_reading.pdf)
  * "McLuhan pointed out that what is most important about a communications medium is *what we have to become* in order to use it fluently." Currently, you have to become part-turing-machine and part-nerd in order to program computers. This is bonkers.
  * O.K. Moore predated Papert and has a notion of "responsive environment" which sounds a lot like a microworld. He also defines the word "autotelic, if engaging in it is done for its own sake rather than for obtaining rewards or avoiding punishments that have no inherent connectino with the activity itself."
  * "One of the interesting rules of the environment is that children can leave any time they want, but they cannot come back until the next day (this is very similar to one of Montessori's principles about choice of toys.)" Very interesting! I'd be curious to read more into the pros and cons of this approach. While it might have the intended first-order effects (getting kids to stick to certain things for longer time, less flitting around), the second-order effects seem uncertain, for example, I wonder if it makes kids feel manipulated or artifically controlled, or another example, if it prevents kids from taking a break when they need one.
  * This seems to be mostly about "Seymour/Socrates in a box" which today is super expensive because you have to create these systems by hand, but one day (maybe soon) could be cheap with AI, which is what the following paper is about...
 

* [Towards Making a Computer Tutor for Children of All Ages - 2016](http://www.vpri.org/pdf/tr2016002_tutor.pdf)
  * "the system may have a database of common user mistakes and advice for correcting them" this sounds similar to the approach I was going to take with IMACS/Samantha
  * They discuss possilities to make a Clippy-like agent the user talks to, should it be older than them? Younger? An expert? Learning it for the first time like them? More than one of them? (It strikes me that statistically there must be someone who wants to learn something and a near-peer who can help them with that thing at the same time. There was a neat iPad app that paired a student 1 chapter ahead with a mentee one chapter behind in SICP. I don't think it took off but I LOVE the idea.) Take into account student pupil size and finger pointing through webcam.
  * In the first phase, having humans do the tutoring while "pretending" to be AI from a remote computer is a good first step to collect data. It's important to collect as much data here as possible, potentially more than a comptuer webcam can capture, so maybe bringing students into an experiment room would be good.
  * The second phase is to begin to build out computer models to detect various user states and "suggest" responses to them that a human can approve of. This sounds eerily similar to the model that many virtual assistant companies, like Clara, are taking, which I find a little nerve-racking because it takes years to test out the riskiest part. I think I'd try my best to not raise money for such a system and instead do it all making money for as long as possible. That is, the students would be paying basically for a human tutor (20% discount or so) but the interface would be indistinguishable from an AI so that you can slowly phase out the human.
  * Another thing that comes to mind here is that teaching comptuer science to teachers isn't *that* hard. Through The Coding Space, we've found it quite scalable. The main thing holding us back, ironically enough, is finding enough use for those teachers, because we can only put them to work 15ish hours per week in afterschool settings, and thus can only hire part-time teachers who are notoriously short-term employees, which means we can't invest as much in their continued development, and they end up giving back to our community of teachers less, which makes it all less scalable.


* [Stream Processing with a Spreadsheet](https://link.springer.com/chapter/10.1007/978-3-662-44202-9_15)
  * skimmed. the calculus went right over my head

* [A Spreadsheet Model for Handling Streaming Data](https://www.cs.cmu.edu/~shihpinc/pdf/Gneiss-CHI15.pdf)
  * really similar in goals to StreamSheets
  * related work by the author: http://dl.acm.org/citation.cfm?id=2647371

* [SIEUFERD Project (database query tool)](http://people.csail.mit.edu/ebakke/sieuferd/index.html)
  * it's like Looker!

* http://strlen.com/treesheets/
  * watched the intro video with one eye. didn't seem relevant to me now

* Look into Codd's relational calulus and relational algebra
  * seems a little too abstract for me now

* http://witheve.com/
  * http://futureofcoding.org/journal#my-first-full-day-with-eve

* http://scattered-thoughts.net
  * http://scattered-thoughts.net/blog/2015/06/04/three-months-of-rust/
    * Interesting to note that JavaScript might not provide the memory control I need
  * Just bought a dozen books based on his reccomendations
  * http://scattered-thoughts.net/blog/2017/03/16/monolog/
    * Looks like he built a tool to track todos with similar goals to the WoofJS Worflow 
  * http://scattered-thoughts.net/blog/2016/10/11/a-practical-relational-query-compiler-in-500-lines/
    * Seems like building a relational database from scratch is hard and over my head
    * In my gut, I feel like I could just implement all of these things in a super dumb way to start in StreamSheets and if that's too slow I can optimize all this later. 
    * Definitely doesn't feel like something I should figure out now. I should wait until its a more urgent and immediate problem.
    * And it feels like I could just use a JS library or something to hack it for now. These things already exsit.
  * [TodoMVC in Imp](https://github.com/jamii/imp/commit/ea4889010e33a5a522ad2015aff42041c3538139)
    * Reminds me a lot of Eve, which is not a suprise because he worked there
    * Not super intuative to read through on first blush.
    * More of his thoughts on the UI library here: http://scattered-thoughts.net/blog/2017/07/28/relational-ui/ 

* https://github.com/jamii/imp
  * Re-watched [Felienne Hermans "Spreadsheets are code lady" video](https://www.youtube.com/watch?v=TMIBfzSqguQ). Really amazing talk. One insight I had is that if you really want to make spreadsheets more like coding, you need to remove cell references. You can reference columns by their names and rows only by performing operations (filters, finds) on a range of rows. Cell references are the pointers of spreadsheets.
  * [Out of the Tarpit](https://github.com/papers-we-love/papers-we-love/blob/master/design/out-of-the-tar-pit.pdf)
    * the reason "closing and reopening" an app or computer is an effective way to fix things is because the software is mishandling state
    * They made a strong argument in 5.2.4 State and Modularity for no hidden state in components, because it's easy but not simple. (My only worry here is that we're losing abstractive power here because abstraction is all about hiding inner details.)
    * In 7.1 Ideal World... "It is interesting to note that effectively what we have just described is in fact the very essence of declarative programming - i.e. that you need only specify what you require and not how it must be achieved."
    * In 7.1.2 Control in the real world, "Clearly if the progrma is to every run, some control will be needed somewhere because things will have to happen in some order - but this should be nor more our concern than the fact that the changes are elecricity will be needed somewhere." Also: The synchrony hypothesis assumes that all finite and stateless computatinos take zero time so its immaterial whether they happen in sequence or in parallel.
    * 7.2.2 Ease of expression, "One possible sittuation of this kind is for derived data which is dependent upon both a series of user inputs over time, and its own previous values."
  * [The Declarative Imperative](http://db.cs.berkeley.edu/papers/sigrec10-declimperative.pdf)
    * seems really similar in goals to Unison. I wonder if Paul Chiusano has seen http://boom.cs.berkeley.edu/
  * [Imp Journal](http://scattered-thoughts.net/journal/)
  
* http://alarmingdevelopment.org/
  * It's pretty insane reading his "manifesto" how similar his ideas about the future programming are to mine a decade later http://alarmingdevelopment.org/?p=5 and http://alarmingdevelopment.org/?p=6
  * Lol, he referes to a Java Query library called JQuery in 2005, before JQuery is created the following year http://alarmingdevelopment.org/?p=16
  * I really like "no assembly required" as a tagline (instead of no installation necccesary)
  * It's interesting to see how much time he spends talking about the hot new company in this space, Dynamic Aspects, (like I do with Eve), especially because I live in the future and know they amounted to nothing
  * Turns out the idea of state as a reduction of history is an old one: "TeaTime radically unifies data and computation by reducing state to the history of communication. Objects interact solely be sending messages to each other. Objects do not have internal state. Instead, they record the history of all messages they have received. State is an illusion derived from the history of message receipts. Messages sends are a determinstic function of the history of received messages. This is an elegant purification of the original model of Object-Oriented programming, reducing it to the sequenced exchange of messages."
  * he has some interesting but over my head and not super intuative thoughts on branches (if-else) http://www.subtext-lang.org/OOPSLA07.pdf
  * Seems like Jonathan spent a lot of time writing papers and worrying about being accepted. 
  * I really like Alan Kay's idea to rewrite all of programming from the ground up, but I acknowledge that it's probably a bad idea because it's like when developers want to throw out their old code and re-write it but on a massive scale and that's a known bad practice (although, I think it usually works great when going from a bad framework to a good one).  http://alarmingdevelopment.org/?p=229
  * It's amazing and hilarious to see how he jumps around from ideas to ideas, from Subtext to syntax, to no syntax, to front-end, to backend web, etc. Really interesting to see what pulls him in different directions, the conferences he applies to, the trends at the time, the competition, his commentors, etc. It's really impressive and humbling to see how honest and vulnerable he is in these posts. http://alarmingdevelopment.org/?p=319
  * it's funny that he backs his way into a typed version of subtext to avoid things like incompleteness http://alarmingdevelopment.org/?p=351 (http://alarmingdevelopment.org/?p=358) as opposed to liking it for its own advantages like I and other Haskell people do. It feels similar to me when people add types to lamda calculus or set theory to avoid certain paradoxes.
  * A really fun post railing against people who think their langauge (LISP in this case) are annoying http://alarmingdevelopment.org/?p=422
  * "The Apes can’t prove their software is correct, and they seem puzzled by the very idea, as if they were being asked to prove correct a chair." http://alarmingdevelopment.org/?p=440
  * A good argument for 1-indexed arrays http://alarmingdevelopment.org/?p=470
  * References https://www.touchdevelop.com. Neat!
  * What a great quote: "The process of constructing instruction tables should be very fascinating. There need be no real danger of it ever becoming a drudge, for any processes that are quite mechanical may be turned over to the machine itself." – Turing, A. M., 1946, Proposed electronic calculator, report for National Physical Laboratory, Teddington
  * Wow, he also spends a lot of time switching languages and frameworks, from Java, to Scala, and back, to JavaScript, to Dart, etc, etc.
  * Good video discussion the pros/cons of static types and way to overcome them and still get the benefits of static typing while also getting metaprogramming https://vimeo.com/74314050

* http://www.expressionsofchange.org/
  * Undo could definitely be made more powerful http://www.expressionsofchange.org/the-power-of-undo/
  * Software changes over time are more complex than I thought. For example, database schema migrations, software packages and dependencies, build tools and containers
  * In order to truly have the expressiveness we want (and other expressiveness we don't even know we want yet), we need to have really composable abstractions about code changes. They must be a first class datatype. (If the code is really just a reduction of all changes, we have a ton of flexibility here.)
  * The ability to "copy and paste" a set of changes to your code is paramount. This is one of the main successes of the command line and failures of GUIs. Point and click is so damn imperative and full of side effects. We really have to get meta fast if we want our GUI to be as powerful as the command line.

* https://github.com/viskell/viskell
  * haskell programming as a graph
  * I don't usually find graphs compelling. I prefer blocks/structured editor approaches which leave the text closer to prose sentences for better reading. I'm not a computer so I don't like reading trees.

* [Conal Elliot - Tangible Functional Programming](https://www.youtube.com/watch?v=faJ8N0giqzw)
  * the dream: combine usability and composability (so like IFFT but at the right level of abstraction)
  * UNIX pipes with input and output text makes it easy to compose
  * I've already seen this video, I'm now realizing, he shows how to drag outputs into inputs in a GUI

* [Conal Elliot - Fran - Composing Reactive Animations](http://conal.net/fran/tutorial.htm)
  * Holy shit! This is like Reactive WoofJS (or the Elm game engine) but was made in 1998 in Haskell! He makes quick work of my "inital value problem": simply give a function all the arugments it needs, starting value, and rate of increase
  * Let me send this over to my friends at McMaster University to see if they've thought about making an Elm version...

* [Conal Elliott - The Essence and Origins of Functional Reactive Programming](https://www.youtube.com/watch?v=j3Q32brCUAI)
  * seperate design spec from implementation
  * FRP is about continuous time in the same way vector graphics are about continuous space
  
* [Conal Elliot - Denotational Design](http://conal.net/papers/type-class-morphisms/)
  * "The purpose of abstraction is not to be vauge but to create a new semantic level in which one can be absolutely precise." - Dijkstra
  * Peter Landin reccomends that "denotive" to replace ill-defined "functional" and "declarative". A langauge is only "denotive" if each expression only depends on sub-expressions
  * before you think about implementation... what are the main types, main operations, what do the types mean?
  * for example, an image is an assignment of colors to 2D locations
  * Turns out Images and Colors are Monads... I should probably understand Applicative, Functor, Monoids, and Monads more
  * I can't get one of his quotes out of my mind. He says that if we do it right, our abstractions will constrain us and disable us from getting certain kinds of information or doing certain things, such as counting how many computation took place on a given image. Part of me likes this non-leaky abstraction but part of me worries that it would be too constraining, and it makes me wonder if there's a middle ground somehow. I feel emotionally that if we had enough self-resembalance and designed our programming language in itself, we might be able to do it.
  
* [Luke Palmer - Semantic Design](https://lukepalmer.wordpress.com/2008/07/18/semantic-design/)
  * references Conal Elliott's work a lot
  * talks about picking the right abstraction and encoding it into types (similar to my idea to kill booleans)

* [Luke Palmer - The purpose of code is to be abstracted over](https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/#comment-1017)

* [Loper OS](http://www.loper-os.org/?p=861)
  * I disagree. I think emacs represents the wrong model: spend a few hundred hours learning this system and we'll improve your brain-computer interface. Instead, why don't we 1) get better abstractions so we have less work (like Paul Chiusano says) and 2) build a more intuiative interface for everyone? 

* [Flowsheets](http://tinyletter.com/Flowsheets/letters/flowsheets-visualizations)
  * neat spreadsheet like interface for python computations

* [Ken Perlin on Chalktalk](https://www.youtube.com/watch?v=xuzrF_82z7U)
  * professor at NYU
  * making magic real with AR/VR. A combo of harold with a crayon and harry potter
  * he has a really interesting medium like Ivan Sutherland's Sketchpad that allows you to create and link together dynamic diagrams. It feels too good to be true, like it was over optimized for this one presentation. I want to see the code on github 
  
* [Jonathan Edwards: Two-way Dataflow](https://vimeo.com/97684085)
  * looks like this turned into [Chorus](http://www.chorus-home.org/)
  * his todomvc example isn't half bad, although I think the react, one-way databinding way that Cycle v2 uses is more in style these days
  * seems like Lamdu does a good job of implementing [his vision for easy-to-use static typing]https://vimeo.com/74314050)
  
* [Francisco Sant’Anna: Dynamic Organisms in Céu](https://vimeo.com/97687022)
  * seems similar to my idea of making a reactive version of Woof or an Elm game engine
  
* [Patrick Dubroy: Moonchild](https://vimeo.com/97711824)
  * I've seen this before. Neat project
  * Allow you to incrementally turn a code editor into a GUI editor, with things like color pickers. It'd be neat if we had this on woofjs.com, so students could see the color in their code and use the color picker right there.
  
* [Mark Mahoney: Version Control Optimized for Teaching and Learning](https://vimeo.com/97711978)
  * it's like seperate conversations for every change of code. So it's like github pull request reviews but on steriods.
  * You can get character by character playback, so it's very much like google docs in that way
  * I admire his goal -- enhancing commit log and explaining code and evolution of system
  * This is related to my idea of putting the commit message first, reversing things, but in a much better and granular way. TODO write up my thoughts here, particularly how you can nest things in a workflowy style
  * wouldn't it be neat if you could query by certain kinds of changes, like adding regex's

* [Bill Burdick: Leisure](https://vimeo.com/97713914)
  * blurs the line between viewing and editing websites
  * "brings the chrome inspector more center stage"
  
* [David Broderick: Kaya: Declarative Reactive](https://vimeo.com/97712270)
  * seems like he'd be a fan of Eve
  
* https://github.com/lamdu/lamdu/
  * really wonderful explaination of many of hte main points of my thesis http://www.lamdu.org/ and https://medium.com/lamdu-blog/designing-programming-languages-with-ides-in-mind-de890989dfa
  * while I still don't really understand even what I'm installing (is it a terminal app or a GUI app), it took me over an hour to install Lamdu on Cloud9, fighting with apt-get, stack, and generally waiting for everything to download and install. Clearly they don't have a sufficient appreciate of the cloud-based nature part of my thesis.
  * I found this wonderful video showing it in action https://vimeo.com/97713439. This video is like Paul's early demo's of Unison but more extensive! I'm blown away. I can't believe I didn't find this sooner. I want to submit a pull request to get them to put this video on their main page. Ok, just did... https://github.com/lamdu/lamdu.github.io/pull/5
  * it's been hours and things still aren't done installing... just updated my c9 instance to have the max RAM and memory
  * More research in my journal here http://futureofcoding.org/journal#july-24-2017-204pm
  * My final notes on Lamdu in my journal here: http://futureofcoding.org/journal#july-25-2017-226pm
  
* [A brief history of "type"](http://arcanesentiment.blogspot.com/2015/01/a-brief-history-of-type.html?m=1)

* [Intentional Programming](https://en.wikipedia.org/wiki/Intentional_programming)
  * I think this stuff is really interesting. If done right, it's similar to how google wants all of their code to be self-documenting. It's probably the exact opposite of Eve's literate programming approach where the code and explaination are two seperate things that humans need to keep in sync.
  * Personally, I find functional programming hard to read / parse meaning from. TODO think about ways we could make FP more readable
  * TODO think about what it would be like to define an entire program in a high-level language and then have to specific the macros to intepret each expression, potentially with Woof. Think about how to zoom in and out on various lines.

* https://en.wikipedia.org/wiki/Deutsch_limit
  * not to be taken seriously. at a worst case, we can put text into visual programming to add density, but density isn't that important after all because we have encapsulation.

* [Additional Notes on "Drawing Dynamic Visualizations"](http://worrydream.com/DrawingDynamicVisualizationsTalkAddendum/)
  * really amazing, inspirational demos! Makes me wonder how Scratch could be more like this and less about the code
    * TODO brainstorm what would be a intuative interface for a student to program gravity from scratch
  * Seems similar to aprt.us, which makes sense because Bret steals from Toby's Recursive Drawing project
  * TODO think about ways to tackle the context problem, helping programmers point to what they want

* [How to Invent the Future II - Alan Kay](https://www.startupschool.org/videos/12)  

* [Alan Kay - how to invent the future pdf](https://www.dropbox.com/s/l4qnf40gksapsrl/Alan%20Kay%20-%20How%20to%20Invent%20the%20Future.pdf?dl=0)

* [Alan Kay - Power of Context](https://www.dropbox.com/s/knngq11tzdi0tdh/Alan%20Kay%20-%20The%20Power%20of%20the%20Context.pdf?dl=0)

* [Always bet on text](http://graydon.livejournal.com/196162.html)
  * text is great for many reasons. I think less so for communicating with comptuers

* [How to Invent the Future I - Alan Kay](https://www.startupschool.org/videos/11) 
  * email him - he loves email!
  * read "the dream machine" about xerox parc / arpa
  * sketchpad is interesting. does object-oriented programming well: master vs instances
    * read ivan sutherland 1962 thesis - man machine communication thesis
  * really great advise on running research community
    * vision, not goals
    * fund people, not projects
    * research community, not research project
    * fund problem finding, not just problem solving
    * milestones, not deadlines
    * be ok with high failure rate
    * just two years for the person running the group
    * solve the problem, don't think about what you can do with the tools you have. make the tools if you need to
    * argue for clarity, not to win
    * keep tabs on people in the "minor leagues"
  * send alan kay about email about learning to communicate with Aliens from integalactic email memo from "Lick"

* Elm
* Hopscotch
* App Lab
* App Inventor
* Bubble.is
* Aprt.us
* http://cirru.org/
* Unison
* http://www.vpri.org/pdf/tr2011001_final_worlds.pdf
* Blockly
* Zapier
* IFFT
* http://origami.design/tutorials/getting-started/Getting-Started.html
* FramerJS
* [Lisp, Smalltalk, and the power of symmetry](https://insearchofsecrets.com/2014/08/04/lisp-smalltalk-and-the-power-of-symmetry/)
* https://medium.com/@stevekrouse/resources-for-creating-front-end-programming-languages-and-frameworks-in-2017-a0c097625f9d

## Where to Find More Links

* http://worrydream.com/dbx/
* http://pgbovine.net/human-centered-programming-tools.htm
* http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/
* http://www.squeakland.org/resources/books/readingList.jsp
* http://worrydream.com

  <script>
  
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-103157758-1', 'auto');
  ga('send', 'pageview');

  </script>
